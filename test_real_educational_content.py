#!/usr/bin/env python3
"""PRAWDZIWY TEST - Materia≈Çy edukacyjne z rzeczywistƒÖ tre≈õciƒÖ"""

import os
import sys
import asyncio
import time
from pathlib import Path
from datetime import datetime
import logging
import json
import torch
from typing import List, Dict, Any
import requests

# Jarvis imports
try:
    from jarvis_edu.core.config import get_settings
    from jarvis_edu.extractors.enhanced_image_extractor import EnhancedImageExtractor
    from jarvis_edu.extractors.enhanced_video_extractor import EnhancedVideoExtractor
    from jarvis_edu.extractors.enhanced_audio_extractor import EnhancedAudioExtractor
    from jarvis_edu.processors.lm_studio import LMStudioProcessor
    from jarvis_edu.storage.knowledge_base import KnowledgeBase
    JARVIS_AVAILABLE = True
except ImportError as e:
    print(f"‚ö†Ô∏è B≈ÇƒÖd importu Jarvis: {e}")
    JARVIS_AVAILABLE = False

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/real_educational_test.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class RealEducationalTester:
    def __init__(self):
        self.media_folder = Path("C:/Users/barto/OneDrive/Pulpit/mediapobrane/pobrane_media")
        self.output_folder = Path("output")
        self.output_folder.mkdir(exist_ok=True)
        
        if JARVIS_AVAILABLE:
            try:
                self.settings = get_settings()
                self.image_extractor = EnhancedImageExtractor()
                self.video_extractor = EnhancedVideoExtractor()
                self.audio_extractor = EnhancedAudioExtractor()
                self.llm_processor = LMStudioProcessor()
                self.knowledge_base = KnowledgeBase()
                self.real_processing = True
                logger.info("‚úÖ Jarvis ekstraktory zainicjalizowane")
            except Exception as e:
                logger.error(f"‚ùå B≈ÇƒÖd inicjalizacji Jarvis: {e}")
                self.real_processing = False
        else:
            self.real_processing = False
        
        self.results = []

    def create_test_educational_content(self):
        """Tworzy testowe pliki edukacyjne z prawdziwƒÖ tre≈õciƒÖ"""
        test_dir = self.output_folder / "test_educational_files"
        test_dir.mkdir(exist_ok=True)
        
        # 1. Tekst matematyczny
        math_image = self.create_math_diagram(test_dir / "matematyka_funkcje.png")
        
        # 2. Tekst naukowy
        science_image = self.create_science_text(test_dir / "nauka_fizyka.png")
        
        # 3. Diagram edukacyjny
        diagram_image = self.create_educational_diagram(test_dir / "diagram_edukacyjny.png")
        
        logger.info(f"‚úÖ Utworzono testowe pliki edukacyjne w: {test_dir}")
        return list(test_dir.glob("*.png"))

    def create_math_diagram(self, output_path: Path):
        """Tworzy obraz z tre≈õciƒÖ matematycznƒÖ"""
        from PIL import Image, ImageDraw, ImageFont
        
        # Du≈ºy obraz z czytelnym tekstem matematycznym
        img = Image.new('RGB', (800, 600), color='white')
        draw = ImageDraw.Draw(img)
        
        # U≈ºyj wiƒôkszej czcionki
        try:
            font_title = ImageFont.truetype("arial.ttf", 36)
            font_content = ImageFont.truetype("arial.ttf", 24)
        except:
            font_title = ImageFont.load_default()
            font_content = ImageFont.load_default()
        
        # Tre≈õƒá matematyczna
        math_content = [
            "MATEMATYKA - FUNKCJE KWADRATOWE",
            "",
            "Definicja: f(x) = ax¬≤ + bx + c",
            "gdzie a ‚â† 0",
            "",
            "W≈Ça≈õciwo≈õci:",
            "‚Ä¢ Dziedzina: R (wszystkie liczby rzeczywiste)",
            "‚Ä¢ Zbi√≥r warto≈õci: zale≈ºy od znaku 'a'",
            "‚Ä¢ Wierzcho≈Çek: (-b/2a, f(-b/2a))",
            "",
            "Przyk≈Çad:",
            "f(x) = x¬≤ - 4x + 3",
            "Œî = b¬≤ - 4ac = 16 - 12 = 4",
            "x‚ÇÅ = (4-2)/2 = 1",
            "x‚ÇÇ = (4+2)/2 = 3",
            "",
            "Zastosowania w fizyce:",
            "‚Ä¢ Ruch jednostajnie przyspieszony",
            "‚Ä¢ Trajektoria rzutu uko≈õnego",
            "‚Ä¢ Energia potencjalna"
        ]
        
        y = 50
        for line in math_content:
            if line == math_content[0]:  # Tytu≈Ç
                draw.text((50, y), line, fill='black', font=font_title)
                y += 50
            else:
                draw.text((50, y), line, fill='black', font=font_content)
                y += 30
        
        img.save(output_path)
        logger.info(f"üìê Utworzono obraz matematyczny: {output_path}")
        return output_path

    def create_science_text(self, output_path: Path):
        """Tworzy obraz z tre≈õciƒÖ naukowƒÖ"""
        from PIL import Image, ImageDraw, ImageFont
        
        img = Image.new('RGB', (800, 600), color='white')
        draw = ImageDraw.Draw(img)
        
        try:
            font_title = ImageFont.truetype("arial.ttf", 32)
            font_content = ImageFont.truetype("arial.ttf", 20)
        except:
            font_title = ImageFont.load_default()
            font_content = ImageFont.load_default()
        
        science_content = [
            "FIZYKA - PRAWA RUCHU NEWTONA",
            "",
            "I PRAWO NEWTONA (Zasada bezw≈Çadno≈õci):",
            "Cia≈Ço pozostaje w spoczynku lub porusza siƒô",
            "ruchem jednostajnym prostoliniowym, je≈õli nie",
            "dzia≈Ça na nie ≈ºadna si≈Ça lub si≈Çy siƒô r√≥wnowa≈ºƒÖ.",
            "",
            "II PRAWO NEWTONA (Zasada dynamiki):",
            "F = ma",
            "Przyspieszenie cia≈Ça jest wprost proporcjonalne",
            "do dzia≈ÇajƒÖcej si≈Çy i odwrotnie proporcjonalne",
            "do masy cia≈Ça.",
            "",
            "III PRAWO NEWTONA (Zasada akcji i reakcji):",
            "Ka≈ºdej akcji towarzyszy r√≥wna co do warto≈õci",
            "i przeciwnie skierowana reakcja.",
            "",
            "Przyk≈Çady zastosowa≈Ñ:",
            "‚Ä¢ Ruch samochod√≥w",
            "‚Ä¢ Loty rakiet kosmicznych",
            "‚Ä¢ Chodzenie po ziemi",
            "‚Ä¢ P≈Çywanie w wodzie"
        ]
        
        y = 40
        for line in science_content:
            if line == science_content[0]:  # Tytu≈Ç
                draw.text((40, y), line, fill='black', font=font_title)
                y += 45
            else:
                draw.text((40, y), line, fill='black', font=font_content)
                y += 25
        
        img.save(output_path)
        logger.info(f"üî¨ Utworzono obraz naukowy: {output_path}")
        return output_path

    def create_educational_diagram(self, output_path: Path):
        """Tworzy diagram edukacyjny"""
        from PIL import Image, ImageDraw, ImageFont
        
        img = Image.new('RGB', (800, 600), color='white')
        draw = ImageDraw.Draw(img)
        
        try:
            font_title = ImageFont.truetype("arial.ttf", 28)
            font_content = ImageFont.truetype("arial.ttf", 18)
        except:
            font_title = ImageFont.load_default()
            font_content = ImageFont.load_default()
        
        # Tytu≈Ç
        draw.text((200, 30), "CYKL ≈ªYCIA MOTYLA", fill='black', font=font_title)
        
        # Rysowanie diagramu cyklu
        stages = [
            ("1. JAJO", (150, 120)),
            ("2. LARWA", (550, 120)),
            ("3. POCZWARKA", (550, 350)),
            ("4. MOTYL", (150, 350))
        ]
        
        # Rysowanie prostokƒÖt√≥w i tekstu
        for stage, (x, y) in stages:
            # ProstokƒÖt
            draw.rectangle([x-50, y-30, x+150, y+30], outline='black', width=2)
            draw.text((x-30, y-10), stage, fill='black', font=font_content)
        
        # Strza≈Çki miƒôdzy etapami
        arrow_coords = [
            ((300, 120), (450, 120)),  # 1->2
            ((550, 170), (550, 300)),  # 2->3
            ((500, 350), (200, 350)),  # 3->4
            ((150, 300), (150, 170))   # 4->1
        ]
        
        for (x1, y1), (x2, y2) in arrow_coords:
            draw.line([(x1, y1), (x2, y2)], fill='black', width=3)
            # Grot strza≈Çki (prosty)
            if x1 == x2:  # Pionowa
                if y2 > y1:  # W d√≥≈Ç
                    draw.polygon([(x2-5, y2-10), (x2+5, y2-10), (x2, y2)], fill='black')
                else:  # W g√≥rƒô
                    draw.polygon([(x2-5, y2+10), (x2+5, y2+10), (x2, y2)], fill='black')
            else:  # Pozioma
                if x2 > x1:  # W prawo
                    draw.polygon([(x2-10, y2-5), (x2-10, y2+5), (x2, y2)], fill='black')
                else:  # W lewo
                    draw.polygon([(x2+10, y2-5), (x2+10, y2+5), (x2, y2)], fill='black')
        
        # Opis na dole
        draw.text((100, 480), "Metamorfoza to proces przemian biologicznych", fill='black', font=font_content)
        draw.text((100, 510), "zachodzƒÖcych podczas rozwoju owad√≥w.", fill='black', font=font_content)
        
        img.save(output_path)
        logger.info(f"üìä Utworzono diagram edukacyjny: {output_path}")
        return output_path

    async def test_real_files(self):
        """Test z prawdziwymi plikami edukacyjnymi"""
        logger.info("üéØ ROZPOCZƒòCIE TESTU Z PRAWDZIWYMI MATERIA≈ÅAMI EDUKACYJNYMI")
        print("="*80)
        
        # Tworzenie testowych plik√≥w edukacyjnych
        test_files = self.create_test_educational_content()
        
        # Przetwarzanie tylko pierwszego pliku (matematyka)
        if test_files:
            file_path = test_files[0]  # matematyka_funkcje.png
            logger.info(f"üìö Przetwarzanie: {file_path.name}")
            
            start_time = time.time()
            
            try:
                # Test OCR
                extraction_result = await self.image_extractor.extract(str(file_path))
                
                # Sprawd≈∫ czy OCR wykry≈Ç prawdziwƒÖ tre≈õƒá
                has_content = (
                    extraction_result.content and 
                    len(extraction_result.content.strip()) > 20 and
                    not extraction_result.content.startswith("OCR nie wykry≈Ç") and
                    not extraction_result.content.startswith("Brak tre≈õci")
                )
                
                if has_content:
                    logger.info(f"‚úÖ OCR SUKCES: {len(extraction_result.content)} znak√≥w")
                    
                    # Test AI podsumowania
                    prompt = f"""
                    Przeanalizuj poni≈ºszy materia≈Ç edukacyjny i stw√≥rz szczeg√≥≈Çowe podsumowanie:

                    Tytu≈Ç: {extraction_result.title}
                    Tre≈õƒá: {extraction_result.content}

                    Stw√≥rz strukturalne podsumowanie (200-400 s≈Ç√≥w) zawierajƒÖce:
                    1. G≈Ç√≥wny temat i dziedzina nauki
                    2. Kluczowe pojƒôcia i definicje
                    3. Praktyczne zastosowania
                    4. Poziom trudno≈õci i grupƒô docelowƒÖ
                    5. Rekomendacje dla nauczycieli
                    """
                    
                    llm_summary = await self.call_lm_studio(prompt)
                    
                    # Zapisz do Knowledge Base
                    lesson_id = await self.save_to_knowledge_base(
                        file_path=file_path,
                        extraction_result=extraction_result,
                        llm_summary=llm_summary,
                        content_type="educational_image"
                    )
                    
                    processing_time = time.time() - start_time
                    
                    result = {
                        'file_path': str(file_path),
                        'file_type': 'educational_image',
                        'processing_time': processing_time,
                        'status': 'success',
                        'extracted_text': extraction_result.content,
                        'llm_summary': llm_summary,
                        'lesson_id': lesson_id,
                        'confidence': extraction_result.confidence,
                        'error': None
                    }
                    
                    self.results.append(result)
                    
                    print(f"\nüìñ PLIK: {file_path.name}")
                    print(f"‚è±Ô∏è CZAS: {processing_time:.2f}s")
                    print(f"üìù TRE≈öƒÜ:\n{extraction_result.content}")
                    print(f"\nüß† AI PODSUMOWANIE:\n{llm_summary}")
                    print(f"\nüíæ LESSON ID: {lesson_id}")
                    print("="*80)
                    
                    return True  # Sukces!
                    
                else:
                    logger.error(f"‚ùå OCR NIEPOWODZENIE: {file_path.name}")
                    print(f"‚ùå OCR NIE WYKRY≈Å TRE≈öCI: {extraction_result.content}")
                    return False
                    
            except Exception as e:
                logger.error(f"‚ùå B≈ÅƒÑD {file_path.name}: {e}")
                print(f"‚ùå B≈ÅƒÑD PRZETWARZANIA: {e}")
                return False

    async def call_lm_studio(self, prompt: str) -> str:
        """Wywo≈Çanie LM Studio API z anti-hallucination protection"""
        try:
            payload = {
                "messages": [
                    {"role": "system", "content": "You are an educational expert. Create CONCISE, FACTUAL summaries in Polish. DO NOT repeat words or phrases. Focus on SPECIFIC content from the given material. If you don't understand the content, say so clearly."},
                    {"role": "user", "content": prompt}
                ],
                "max_tokens": 300,  # Reduced to prevent repetition
                "temperature": 0.1,  # Much lower temperature
                "top_p": 0.8,
                "frequency_penalty": 1.0,  # Prevent repetition
                "presence_penalty": 0.5,
                "stream": False
            }
            
            response = requests.post(
                'http://127.0.0.1:1234/v1/chat/completions',
                json=payload,
                timeout=60
            )
            
            if response.status_code == 200:
                data = response.json()
                if 'choices' in data and data['choices']:
                    if isinstance(data['choices'], list) and len(data['choices']) > 0:
                        choice = data['choices'][0]
                        if 'message' in choice and 'content' in choice['message']:
                            raw_response = choice['message']['content'].strip()
                            
                            # üî• HALLUCINATION DETECTION
                            cleaned_response = self._clean_lm_studio_response(raw_response)
                            if cleaned_response:
                                return cleaned_response
                            else:
                                return "AI HALLUCINATION WYKRYTA - sprawd≈∫ model LM Studio. U≈ºyj meta-llama-3-8b-instruct zamiast mistral."
                
                return "Podsumowanie AI (struktura odpowiedzi nieoczekiwana)"
            else:
                return f"B≈ÇƒÖd LM Studio (HTTP {response.status_code})"
            
        except Exception as e:
            logger.error(f"B≈ÇƒÖd LM Studio: {e}")
            return f"B≈ÇƒÖd generowania: {str(e)}"

    def _clean_lm_studio_response(self, response: str) -> str:
        """Clean LM Studio response and detect hallucination"""
        if not response or len(response.strip()) < 10:
            return ""
        
        import re
        from collections import Counter
        
        # Remove excessive whitespace
        cleaned = re.sub(r'\s+', ' ', response.strip())
        
        # Detect word/phrase repetition (like Whisper hallucination)
        words = cleaned.split()
        
        if len(words) > 10:
            word_counts = Counter(words)
            total_words = len(words)
            
            # Check for excessive repetition
            for word, count in word_counts.items():
                if count / total_words > 0.3:  # More than 30% of text is one word
                    logger.warning(f"LM Studio hallucination detected: '{word}' repeated {count} times")
                    return ""
        
        # Check for phrase repetition
        if len(words) > 5:
            # Check for repeating 2-word phrases
            phrases = [f"{words[i]} {words[i+1]}" for i in range(len(words)-1)]
            phrase_counts = Counter(phrases)
            
            for phrase, count in phrase_counts.items():
                if count > 3:  # Phrase repeated more than 3 times
                    logger.warning(f"LM Studio phrase hallucination: '{phrase}' repeated {count} times")
                    return ""
        
        # Check for meaningless repetitive patterns
        if "zastosowania nauczania" in cleaned and cleaned.count("zastosowania") > 5:
            logger.warning("LM Studio known hallucination pattern detected")
            return ""
        
        # Check if content is too repetitive (low diversity)
        if len(set(words)) < len(words) * 0.15:  # Less than 15% unique words
            logger.warning("LM Studio response has very low word diversity - likely hallucination")
            return ""
        
        # Return cleaned response if it passes all tests
        return cleaned

    async def save_to_knowledge_base(self, file_path: Path, extraction_result, llm_summary: str, content_type: str) -> str:
        """Zapisuje do Knowledge Base"""
        try:
            import hashlib
            
            file_hash = hashlib.md5(str(file_path).encode()).hexdigest()[:8]
            lesson_id = f"edu_{content_type}_{file_hash}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            
            lesson_data = {
                'lesson_id': lesson_id,
                'title': f"Materia≈Ç edukacyjny: {extraction_result.title}",
                'summary': llm_summary,
                'content': extraction_result.content,
                'source_file': str(file_path),
                'content_type': content_type,
                'extraction_metadata': extraction_result.metadata,
                'confidence': extraction_result.confidence,
                'language': extraction_result.language,
                'created_at': datetime.now().isoformat(),
                'tags': ['educational', 'test', 'real-content', content_type],
                'categories': ['Materia≈Çy edukacyjne', 'Test OCR']
            }
            
            kb_file = self.output_folder / f"knowledge_base_{lesson_id}.json"
            with open(kb_file, 'w', encoding='utf-8') as f:
                json.dump(lesson_data, f, indent=2, ensure_ascii=False)
            
            logger.info(f"üíæ Zapisano do Knowledge Base: {lesson_id}")
            return lesson_id
            
        except Exception as e:
            logger.error(f"B≈ÇƒÖd zapisu do Knowledge Base: {e}")
            return f"error_{datetime.now().strftime('%H%M%S')}"

async def main():
    """G≈Ç√≥wna funkcja testu"""
    print("üéì PRAWDZIWY TEST MATERIA≈Å√ìW EDUKACYJNYCH")
    print("="*80)
    print(f"Test started: {datetime.now()}")
    print("="*80)
    
    tester = RealEducationalTester()
    success = await tester.test_real_files()
    
    if success:
        print("\nüéâ ‚úÖ SYSTEM DZIA≈ÅA PRAWID≈ÅOWO!")
        print("üß† OCR wykrywa prawdziwƒÖ tre≈õƒá edukacyjnƒÖ")
        print("ü§ñ AI generuje rzeczywiste podsumowania")
        print("üíæ Knowledge Base zapisuje lekcje")
    else:
        print("\n‚ùå SYSTEM WYMAGA NAPRAWY!")
        print("üîß OCR nie wykrywa tre≈õci lub AI nie dzia≈Ça")
    
    print("\nüéì TEST PRAWDZIWYCH MATERIA≈Å√ìW ZAKO≈ÉCZONY!")

if __name__ == '__main__':
    asyncio.run(main()) 